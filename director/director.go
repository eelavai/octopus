package director

import (
	"github.com/eelavai/octopus/agent"
	"github.com/eelavai/octopus/exit"
	"github.com/eelavai/octopus/harness"
	"github.com/eelavai/octopus/network"
	"github.com/eelavai/octopus/state"
	"math/rand"
	"stripe-ctf.com/log"
	"time"
)

// Apologies to Netflix and Chaos Monkey
type MonkeyConfig struct {
	offset, frequency, ramp time.Duration
}

// These numbers were scientifically generated by thinking really hard for the
// better part of two seconds.
var monkeys = map[string]*MonkeyConfig{
	// Network monkeys
	"latency":  &MonkeyConfig{0, 1 * time.Second, 0},
	"jitter":   &MonkeyConfig{0 * time.Second, 1 * time.Second, 30 * time.Second},
	"lagsplit": &MonkeyConfig{0 * time.Second, 2 * time.Second, 60 * time.Second},
	"link":     &MonkeyConfig{3 * time.Second, 3 * time.Second, 30 * time.Second},
	"netsplit": &MonkeyConfig{5 * time.Second, 5 * time.Second, 60 * time.Second},
	// Agent monkeys
	// "freeze": &MonkeyConfig{15 * time.Second, 5 * time.Second, 30 * time.Second},
	// "murder": &MonkeyConfig{45 * time.Second, 10 * time.Second, 30 * time.Second},
}

type Director struct {
	g       *exit.WaitGroup
	net     *network.Network
	config  map[string]*MonkeyConfig
	agents  agent.List
	harness *harness.Harness
}

func NewDirector() *Director {
	agents := agent.NewList()

	return &Director{
		agents:  agents,
		net:     network.New(),
		config:  monkeys,
		harness: harness.New(agents),
	}
}

func (d *Director) Dryrun() {
	d.agents.Dryrun()
}

func (d *Director) Start() {
	rng := state.NewRand("director")
	d.harness.Start()

	// Give a 100ms grace period for startup
	time.Sleep(100 * time.Millisecond)

	// Set up directories
	d.agents.Prepare()

	// Populate initial link latencies
	for _, link := range d.net.Links() {
		link.SetLatency(d.makeLatency(rng, 0))
		link.SetJitter(d.makeJitter(rng, 0))
	}
	d.net.Start()
	for monkey, _ := range monkeys {
		go d.spawn(monkey)
	}
	d.agents.Start()
}

func (d *Director) makeLatency(rng *rand.Rand, intensity float64) uint {
	l := int((20 + rng.NormFloat64()*10) * (1 + intensity))
	if l < 1 {
		return 1
	} else {
		return uint(l)
	}
}
func (d *Director) makeJitter(rng *rand.Rand, intensity float64) uint {
	return uint(rng.Intn(int(2 * (1 + intensity))))
}
func (d *Director) makeDuration(rng *rand.Rand, scale, intensity float64) time.Duration {
	t := int(scale * (1 + intensity))
	return time.Duration(rng.Intn(t)) * time.Millisecond
}

func (d *Director) randomLink(rng *rand.Rand) *network.Link {
	links := d.net.Links()
	choice := rng.Intn(len(links))
	return links[choice]
}

func (d *Director) randomPartition(rng *rand.Rand) []*network.Link {
	count := state.NodeCount()

	// If there are fewer than three nodes, netsplits are pretty
	// boring
	if count < 3 {
		return []*network.Link{d.net.Links()[0]}
	}
	perm := rng.Perm(count)
	splitPoint := rng.Intn(count-2) + 1
	split := make([]uint, 0)
	for i := 0; i < splitPoint; i++ {
		split = append(split, uint(perm[i]))
	}
	log.Printf("Made a netsplit: %v", split)
	return d.net.FindPerimeter(split)
}

func (d *Director) randomAgent(rng *rand.Rand) *agent.Agent {
	choice := rng.Intn(len(d.agents))
	return d.agents[choice]
}
